#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+OPTIONS: html-scripts:t html-style:t html5-fancy:nil tex:t
#+HTML_DOCTYPE: xhtml-strict
#+HTML_CONTAINER: div
#+DESCRIPTION:
#+KEYWORDS:
#+HTML_LINK_HOME:
#+HTML_LINK_UP:
#+HTML_MATHJAX:
#+HTML_HEAD:
#+HTML_HEAD_EXTRA:
#+SUBTITLE:
#+INFOJS_OPT:
#+CREATOR: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 25.3.2 (<a href="http://orgmode.org">Org</a> mode 9.1.2)
#+LATEX_HEADER:

#+TITLE: Design and Implementation of Semantic Segmentation

* system parameters

#+NAME:parameters
#+BEGIN_SRC python :noweb yes :tangle :exports none
  # NUM_CLASSES = 2
  # IMAGE_SHAPE = (160, 576)

  EPOCHS = 20
  BATCH_SIZE = 1

  LEARNING_RATE = 0.0009 # 0.0001
  DROPOUT = 0.5 # 0.75
#+END_SRC

* Global variables

#+NAME:globals
#+BEGIN_SRC python :noweb yes :tangle :exports none
  average_losses = []             # for plotting the average_losses
#+END_SRC

* load_vgg

#+NAME:load_vgg
#+BEGIN_SRC python :noweb yes :tangle :exports none
  def load_vgg(sess, vgg_path):
        """
        Load Pretrained VGG Model into TensorFlow.
        :param sess: TensorFlow Session
        :param vgg_path: Path to vgg folder, containing "variables/" and "saved_model.pb"
        :return: Tuple of Tensors from VGG model (image_input, keep_prob, layer3_out, layer4_out, layer7_out)
        """
        # TODO: Implement function
        #   Use tf.saved_model.loader.load to load the model and weights
        vgg_tag = 'vgg16'
        vgg_input_tensor_name = 'image_input:0'
        vgg_keep_prob_tensor_name = 'keep_prob:0'
        vgg_layer3_out_tensor_name = 'layer3_out:0'
        vgg_layer4_out_tensor_name = 'layer4_out:0'
        vgg_layer7_out_tensor_name = 'layer7_out:0'

        tf.save_model.loader.load(sess, [vgg_tag], vgg_tag)
        graph = tf.get_default_graph()
        image_input = graph.get_tensor_by_name(vgg_input_tensor_name)
        keep_prob   = graph.get_tensor_by_name(vgg_keep_prob_tensor_name)
        layer3_out_raw = graph.get_tensor_by_name(vgg_layer3_out_tensor_name)
        layer4_out_raw = graph.get_tensor_by_name(vgg_layer4_out_tensor_name)
        layer7_out = graph.get_tensor_by_name(vgg_layer7_out_tensor_name)

        # the following scaling is based on the suggestion from
        # https://discussions.udacity.com/t/here-is-some-advice-and-clarifications-about-the-semantic-segmentation-project/403100
        layer3_out_scaled = tf.multiply(layer3_out_raw, 0.0001, name='layer3_out_scaled')
        layer4_out_scaled = tf.multiply(layer4_out_raw, 0.01, name='layer4_out_scaled')

        return image_input, keep_prob, layer3_out_scaled, layer4_out_scaled, layer7_out
#+END_SRC

* layers

The construction of the FCN model.

#+NAME:conv_1x1
#+BEGIN_SRC python :noweb yes :tangle :exports none
  def conv_1x1(layer, layer_name, num_classes):
      """
      'return the 1x1 convolution of a layer
      """
      return tf.layers.conv2d(inputs=layer,
                              num_classes,
                              kernel_size=(1, 1),
                              strides=(1, 1),
                              padding= 'same',
                              kernel_initializer= tf.random_normal_initializer(stddev=0.01),
                              kernel_regularizer= tf.contrib.layers.l2_regularizer(1e-3),
                              name=layer_name)
#+END_SRC

#+NAME:upsample
#+BEGIN_SRC python :noweb yes :tangle :exports none
  def upsample(layer, kernel, stride, layer_name, num_classes):
      """
      return the convolution transpose of the layer given kernel and stride.
      """
      return tf.layers.conv2d_traspose(inputs=layer,
                                       filters=num_classes,
                                       kernel_size=(kernel, kernel),
                                       strides=(stride, stride),
                                       padding='same',
                                       kernel_initializer= tf.random_normal_initializer(stddev=0.01),
                                       kernel_regularizer= tf.contrib.layers.l2_regularizer(1e-3),
                                       name=layer_name)
#+END_SRC

#+NAME:layers
#+BEGIN_SRC python :noweb yes :tangle :exports none
  <<conv_1x1>>
  <<upsample>>
  def layers(vgg_layer3_out, vgg_layer4_out, vgg_layer7_out, num_classes):
      """
      Create the layers for a fully convolutional network.  Build skip-layers using the vgg layers.
      :param vgg_layer7_out: TF Tensor for VGG Layer 3 output
      :param vgg_layer4_out: TF Tensor for VGG Layer 4 output
      :param vgg_layer3_out: TF Tensor for VGG Layer 7 output
      :param num_classes: Number of classes to classify
      :return: The Tensor for the last layer of output
      """
      # TODO: Implement function
      l7_conv = conv_1x1(vgg_layer7_out, 'l7_conv', num_classes)
      l4_conv = conv_1x1(vgg_layer4_out, 'l4_conv', num_classes)
      l3_conv = conv_1x1(vgg_layer3_out, 'l3_conv', num_classes)

      l7_conv_upsample = upsample(l7_conv, 4, 2, 'l7_conv_upsample', num_classes)
      # add skip l4_conv
      l4_skip_added = tf.add(l7_conv_upsample, l4_conv)
      l4_skip_added_upsample = upsample(l4_skip_added, 4, 2, "l4_skip_added_upsample", num_classes)
      l3_skip_added = tf.add(l4_skip_added_upsample, l3_conv)
      output = upsample(l3_skip_added, 16, 8, 'output', num_classes)

      # example of print out the dimension for debug
      # tf.Print(output, [tf.shape(output)[1:3]])
      return output
#+END_SRC

* optimize

#+NAME:optimize
#+BEGIN_SRC python :noweb yes :tangle :exports none
  def optimize(nn_last_layer, correct_label, learning_rate, num_classes):
      """
      Build the TensorFLow loss and optimizer operations.
      :param nn_last_layer: TF Tensor of the last layer in the neural network
      :param correct_label: TF Placeholder for the correct label image
      :param learning_rate: TF Placeholder for the learning rate
      :param num_classes: Number of classes to classify
      :return: Tuple of (logits, train_op, cross_entropy_loss)
      """
      # TODO: Implement function
      # make logits a 2D tensor where each row represents a pxel and each column a class
      logits = tf.reshape(nn_last_layer, (-1, num_classes))
      correct_label = tf.reshape(correct_label, (-1, num_classes))

      # define loss function
      cross_entropy_loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=logits,
                                                                                  label=correct_label))
      # training operation
      optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate)
      train_op = optimizer.minimize(cross_entropy_loss)
      return logits, train_op, cross_entropy_loss
#+END_SRC

* train_nn

#+NAME:train_nn
#+BEGIN_SRC python :noweb yes :tangle :exports none
  def train_nn(sess, epochs, batch_size, get_batches_fn, train_op, cross_entropy_loss, input_image,
               correct_label, keep_prob, learning_rate):
      """
      Train neural network and print out the loss during training.
      :param sess: TF Session
      :param epochs: Number of epochs
      :param batch_size: Batch size
      :param get_batches_fn: Function to get batches of training data.  Call using get_batches_fn(batch_size)
      :param train_op: TF Operation to train the neural network
      :param cross_entropy_loss: TF Tensor for the amount of loss
      :param input_image: TF Placeholder for input images
      :param correct_label: TF Placeholder for label images
      :param keep_prob: TF Placeholder for dropout keep probability
      :param learning_rate: TF Placeholder for learning rate
      """
      # TODO: Implement function
      // sess.run(tf.global_variables_initializer())

      print("Training...")
      print()
      losses = []
      for epoch in range(epochs):
          print("EPOCH {} ...".format(epoch))
          for image, label in get_batches_fn(batch_size):
              # performe training
              _, loss = sess.run([train_op, cross_entropy_loss],
                                 feed_dict={input_image: image,
                                            correct_label: label,
                                            keep_prob: LEARNING_RATE,
                                            learning_rate: DROPOUT})
              losses.append(loss)  # record loss for plotting
          #end of for image, label
          average_loss = sum(losses)/len(losses)
          average_losses = append(average_losses)

          print("Loss: = {:.3f}".format(loss))
      #end of for epoch
      print()
#+END_SRC

* run

#+NAME:run
#+BEGIN_SRC python :noweb yes :tangle :exports none
  def run():
      num_classes = 2
      image_shape = (160, 576)
      data_dir = './data'
      runs_dir = './runs'
      tests.test_for_kitti_dataset(data_dir)

      # Download pretrained vgg model
      helper.maybe_download_pretrained_vgg(data_dir)

      # OPTIONAL: Train and Inference on the cityscapes dataset instead of the Kitti dataset.
      # You'll need a GPU with at least 10 teraFLOPS to train on.
      #  https://www.cityscapes-dataset.com/

      with tf.Session() as sess:
          # Path to vgg model
          vgg_path = os.path.join(data_dir, 'vgg')
          # Create function to get batches
          get_batches_fn = helper.gen_batch_function(os.path.join(data_dir, 'data_road/training'), image_shape)

          # OPTIONAL: Augment Images for better results
          #  https://datascience.stackexchange.com/questions/5224/how-to-prepare-augment-images-for-neural-network

          # TODO: Build NN using load_vgg, layers, and optimize function
          # TF placeholders
          correct_label = tf.placeholde(tf.int32, [None, None, None, num_classes], name='correct_label')
          learning_rate = tf.placeholder(tf.float32, name='learning_rate')

          input_image, keep_prob, layer3_out, layer4_out, layer7_out = load_vgg(sess, vgg_path)
          model_output = layers(layer3_out, layer4_out, layer7_out, num_classes)

          logits, train_op, cross_entropy_loss = optimize(model_output, correct_label, learning_rate, num_classes);

          # TODO: Train NN using the train_nn function

          # initialize variables
          sess.run(tf.gloabl_variables_initializer())
          sess.run(tf.local_variables_initializer())

          train_nn(sess, EPOCHS, BATCH_SIZE, get_batches_fn,
                   train_op, cross_entropy_loss, input_image, correct_label, keep_prob, learning_rate)

          # TODO: Save inference data using helper.save_inference_samples
          helper.save_inference_samples(runs_dir, data_dir, sess, image_shape, logits, keep_prob, input_image)

          # OPTIONAL: Apply the trained model to a video


#+END_SRC

* main
#+NAME:main
#+BEGIN_SRC python :noweb tangle :tangle ./main.py
  import os.path
  import tensorflow as tf
  import helper
  import warnings
  from distutils.version import LooseVersion
  import project_tests as tests

  <<parameters>>
  <<globals>>

  # Check TensorFlow Version
  assert LooseVersion(tf.__version__) >= LooseVersion('1.0'), 'Please use TensorFlow version 1.0 or newer.  You are using {}'.format(tf.__version__)
  print('TensorFlow Version: {}'.format(tf.__version__))

  # Check for a GPU
  if not tf.test.gpu_device_name():
      warnings.warn('No GPU found. Please use a GPU to train your neural network.')
  else:
      print('Default GPU Device: {}'.format(tf.test.gpu_device_name()))

  <<load_vgg>>
  tests.test_load_vgg(load_vgg, tf)

  <<layers>>
  tests.test_layers(layers)

  <<optimize>>
  tests.test_optimize(optimize)

  <<train_nn>>
  tests.test_train_nn(train_nn)

  <<run>>

  if __name__ == '__main__':
      run()
      print(average_losses)
#+END_SRC

#+NAME:helper
#+BEGIN_SRC python :noweb yes :tangle :exports none
import re
import random
import numpy as np
import os.path
import scipy.misc
import shutil
import zipfile
import time
import tensorflow as tf
from glob import glob
from urllib.request import urlretrieve
from tqdm import tqdm


class DLProgress(tqdm):
    last_block = 0

    def hook(self, block_num=1, block_size=1, total_size=None):
        self.total = total_size
        self.update((block_num - self.last_block) * block_size)
        self.last_block = block_num


def maybe_download_pretrained_vgg(data_dir):
    """
    Download and extract pretrained vgg model if it doesn't exist
    :param data_dir: Directory to download the model to
    """
    vgg_filename = 'vgg.zip'
    vgg_path = os.path.join(data_dir, 'vgg')
    vgg_files = [
        os.path.join(vgg_path, 'variables/variables.data-00000-of-00001'),
        os.path.join(vgg_path, 'variables/variables.index'),
        os.path.join(vgg_path, 'saved_model.pb')]

    missing_vgg_files = [vgg_file for vgg_file in vgg_files if not os.path.exists(vgg_file)]
    if missing_vgg_files:
        # Clean vgg dir
        if os.path.exists(vgg_path):
            shutil.rmtree(vgg_path)
        os.makedirs(vgg_path)

        # Download vgg
        print('Downloading pre-trained vgg model...')
        with DLProgress(unit='B', unit_scale=True, miniters=1) as pbar:
            urlretrieve(
                'https://s3-us-west-1.amazonaws.com/udacity-selfdrivingcar/vgg.zip',
                os.path.join(vgg_path, vgg_filename),
                pbar.hook)

        # Extract vgg
        print('Extracting model...')
        zip_ref = zipfile.ZipFile(os.path.join(vgg_path, vgg_filename), 'r')
        zip_ref.extractall(data_dir)
        zip_ref.close()

        # Remove zip file to save space
        os.remove(os.path.join(vgg_path, vgg_filename))


def gen_batch_function(data_folder, image_shape):
    """
    Generate function to create batches of training data
    :param data_folder: Path to folder that contains all the datasets
    :param image_shape: Tuple - Shape of image
    :return:
    """
    def get_batches_fn(batch_size):
        """
        Create batches of training data
        :param batch_size: Batch Size
        :return: Batches of training data
        """
        image_paths = glob(os.path.join(data_folder, 'image_2', '*.png'))
        label_paths = {
            re.sub(r'_(lane|road)_', '_', os.path.basename(path)): path
            for path in glob(os.path.join(data_folder, 'gt_image_2', '*_road_*.png'))}
        background_color = np.array([255, 0, 0])

        random.shuffle(image_paths)
        for batch_i in range(0, len(image_paths), batch_size):
            images = []
            gt_images = []
            for image_file in image_paths[batch_i:batch_i+batch_size]:
                gt_image_file = label_paths[os.path.basename(image_file)]

                image = scipy.misc.imresize(scipy.misc.imread(image_file), image_shape)
                gt_image = scipy.misc.imresize(scipy.misc.imread(gt_image_file), image_shape)

                gt_bg = np.all(gt_image == background_color, axis=2)
                gt_bg = gt_bg.reshape(*gt_bg.shape, 1)
                gt_image = np.concatenate((gt_bg, np.invert(gt_bg)), axis=2)

                images.append(image)
                gt_images.append(gt_image)

            yield np.array(images), np.array(gt_images)
    return get_batches_fn


def gen_test_output(sess, logits, keep_prob, image_pl, data_folder, image_shape):
    """
    Generate test output using the test images
    :param sess: TF session
    :param logits: TF Tensor for the logits
    :param keep_prob: TF Placeholder for the dropout keep robability
    :param image_pl: TF Placeholder for the image placeholder
    :param data_folder: Path to the folder that contains the datasets
    :param image_shape: Tuple - Shape of image
    :return: Output for for each test image
    """
    for image_file in glob(os.path.join(data_folder, 'image_2', '*.png')):
        image = scipy.misc.imresize(scipy.misc.imread(image_file), image_shape)

        im_softmax = sess.run(
            [tf.nn.softmax(logits)],
            {keep_prob: 1.0, image_pl: [image]})
        im_softmax = im_softmax[0][:, 1].reshape(image_shape[0], image_shape[1])
        segmentation = (im_softmax > 0.5).reshape(image_shape[0], image_shape[1], 1)
        mask = np.dot(segmentation, np.array([[0, 255, 0, 127]]))
        mask = scipy.misc.toimage(mask, mode="RGBA")
        street_im = scipy.misc.toimage(image)
        street_im.paste(mask, box=None, mask=mask)

        yield os.path.basename(image_file), np.array(street_im)


def save_inference_samples(runs_dir, data_dir, sess, image_shape, logits, keep_prob, input_image):
    # Make folder for current run
    output_dir = os.path.join(runs_dir, str(time.time()))
    if os.path.exists(output_dir):
        shutil.rmtree(output_dir)
    os.makedirs(output_dir)

    # Run NN on test images and save them to HD
    print('Training Finished. Saving test images to: {}'.format(output_dir))
    image_outputs = gen_test_output(
        sess, logits, keep_prob, input_image, os.path.join(data_dir, 'data_road/testing'), image_shape)
    for name, image in image_outputs:
        scipy.misc.imsave(os.path.join(output_dir, name), image)

#+END_SRC

#+NAME:project_tests
#+BEGIN_SRC python :noweb yes :tangle :exports none
import sys
import os
from copy import deepcopy
from glob import glob
from unittest import mock

import numpy as np
import tensorflow as tf


def test_safe(func):
    """
    Isolate tests
    """
    def func_wrapper(*args):
        with tf.Graph().as_default():
            result = func(*args)
        print('Tests Passed')
        return result

    return func_wrapper


def _prevent_print(function, params):
    sys.stdout = open(os.devnull, "w")
    function(**params)
    sys.stdout = sys.__stdout__


def _assert_tensor_shape(tensor, shape, display_name):
    assert tf.assert_rank(tensor, len(shape), message='{} has wrong rank'.format(display_name))

    tensor_shape = tensor.get_shape().as_list() if len(shape) else []

    wrong_dimension = [ten_dim for ten_dim, cor_dim in zip(tensor_shape, shape)
                       if cor_dim is not None and ten_dim != cor_dim]
    assert not wrong_dimension, \
        '{} has wrong shape.  Found {}'.format(display_name, tensor_shape)


class TmpMock(object):
    """
    Mock a attribute.  Restore attribute when exiting scope.
    """
    def __init__(self, module, attrib_name):
        self.original_attrib = deepcopy(getattr(module, attrib_name))
        setattr(module, attrib_name, mock.MagicMock())
        self.module = module
        self.attrib_name = attrib_name

    def __enter__(self):
        return getattr(self.module, self.attrib_name)

    def __exit__(self, type, value, traceback):
        setattr(self.module, self.attrib_name, self.original_attrib)


@test_safe
def test_load_vgg(load_vgg, tf_module):
    with TmpMock(tf_module.saved_model.loader, 'load') as mock_load_model:
        vgg_path = ''
        sess = tf.Session()
        test_input_image = tf.placeholder(tf.float32, name='image_input')
        test_keep_prob = tf.placeholder(tf.float32, name='keep_prob')
        test_vgg_layer3_out = tf.placeholder(tf.float32, name='layer3_out')
        test_vgg_layer4_out = tf.placeholder(tf.float32, name='layer4_out')
        test_vgg_layer7_out = tf.placeholder(tf.float32, name='layer7_out')

        input_image, keep_prob, vgg_layer3_out, vgg_layer4_out, vgg_layer7_out = load_vgg(sess, vgg_path)

        assert mock_load_model.called, \
            'tf.saved_model.loader.load() not called'
        assert mock_load_model.call_args == mock.call(sess, ['vgg16'], vgg_path), \
            'tf.saved_model.loader.load() called with wrong arguments.'

        assert input_image == test_input_image, 'input_image is the wrong object'
        assert keep_prob == test_keep_prob, 'keep_prob is the wrong object'
        assert vgg_layer3_out == test_vgg_layer3_out, 'layer3_out is the wrong object'
        assert vgg_layer4_out == test_vgg_layer4_out, 'layer4_out is the wrong object'
        assert vgg_layer7_out == test_vgg_layer7_out, 'layer7_out is the wrong object'


@test_safe
def test_layers(layers):
    num_classes = 2
    vgg_layer3_out = tf.placeholder(tf.float32, [None, None, None, 256])
    vgg_layer4_out = tf.placeholder(tf.float32, [None, None, None, 512])
    vgg_layer7_out = tf.placeholder(tf.float32, [None, None, None, 4096])
    layers_output = layers(vgg_layer3_out, vgg_layer4_out, vgg_layer7_out, num_classes)

    _assert_tensor_shape(layers_output, [None, None, None, num_classes], 'Layers Output')


@test_safe
def test_optimize(optimize):
    num_classes = 2
    shape = [2, 3, 4, num_classes]
    layers_output = tf.Variable(tf.zeros(shape))
    correct_label = tf.placeholder(tf.float32, [None, None, None, num_classes])
    learning_rate = tf.placeholder(tf.float32)
    logits, train_op, cross_entropy_loss = optimize(layers_output, correct_label, learning_rate, num_classes)

    _assert_tensor_shape(logits, [2*3*4, num_classes], 'Logits')

    with tf.Session() as sess:
        sess.run(tf.global_variables_initializer())
        sess.run([train_op], {correct_label: np.arange(np.prod(shape)).reshape(shape), learning_rate: 10})
        test, loss = sess.run([layers_output, cross_entropy_loss], {correct_label: np.arange(np.prod(shape)).reshape(shape)})

    assert test.min() != 0 or test.max() != 0, 'Training operation not changing weights.'


@test_safe
def test_train_nn(train_nn):
    epochs = 1
    batch_size = 2

    def get_batches_fn(batach_size_parm):
        shape = [batach_size_parm, 2, 3, 3]
        return np.arange(np.prod(shape)).reshape(shape)

    train_op = tf.constant(0)
    cross_entropy_loss = tf.constant(10.11)
    input_image = tf.placeholder(tf.float32, name='input_image')
    correct_label = tf.placeholder(tf.float32, name='correct_label')
    keep_prob = tf.placeholder(tf.float32, name='keep_prob')
    learning_rate = tf.placeholder(tf.float32, name='learning_rate')
    with tf.Session() as sess:
        parameters = {
            'sess': sess,
            'epochs': epochs,
            'batch_size': batch_size,
            'get_batches_fn': get_batches_fn,
            'train_op': train_op,
            'cross_entropy_loss': cross_entropy_loss,
            'input_image': input_image,
            'correct_label': correct_label,
            'keep_prob': keep_prob,
            'learning_rate': learning_rate}
        _prevent_print(train_nn, parameters)


@test_safe
def test_for_kitti_dataset(data_dir):
    kitti_dataset_path = os.path.join(data_dir, 'data_road')
    training_labels_count = len(glob(os.path.join(kitti_dataset_path, 'training/gt_image_2/*_road_*.png')))
    training_images_count = len(glob(os.path.join(kitti_dataset_path, 'training/image_2/*.png')))
    testing_images_count = len(glob(os.path.join(kitti_dataset_path, 'testing/image_2/*.png')))

    assert not (training_images_count == training_labels_count == testing_images_count == 0),\
        'Kitti dataset not found. Extract Kitti dataset in {}'.format(kitti_dataset_path)
    assert training_images_count == 289, 'Expected 289 training images, found {} images.'.format(training_images_count)
    assert training_labels_count == 289, 'Expected 289 training labels, found {} labels.'.format(training_labels_count)
    assert testing_images_count == 290, 'Expected 290 testing images, found {} images.'.format(testing_images_count)

#+END_SRC
